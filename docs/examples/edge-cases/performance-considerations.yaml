# Performance Considerations and Edge Cases
# Demonstrates scenarios where GenLogic optimizations matter most

columns:
  id:
    type: integer
    sequence: true
    primary_key: true

  amount:
    type: numeric
    size: 12
    decimal: 2

  timestamp:
    type: timestamp

tables:
  # CASE 1: High-volume transaction processing
  # Millions of transactions, frequent inserts
  bank_accounts:
    columns:
      account_id:
        $ref: id

      # Multiple automations on same FK - GenLogic consolidates into ONE trigger
      balance:
        $ref: amount
        automation:
          type: SUM
          table: bank_transactions
          foreign_key: account_fk
          column: amount

      transaction_count:
        type: integer
        automation:
          type: COUNT
          table: bank_transactions
          foreign_key: account_fk
          column: transaction_id

      largest_deposit:
        $ref: amount
        automation:
          type: MAX
          table: bank_transactions
          foreign_key: account_fk
          column: amount

      largest_withdrawal:
        $ref: amount
        automation:
          type: MIN
          table: bank_transactions
          foreign_key: account_fk
          column: amount

      last_transaction_time:
        $ref: timestamp
        automation:
          type: LATEST
          table: bank_transactions
          foreign_key: account_fk
          column: created_at

      # Performance benefit: 5 automations = 1 trigger function
      # Each INSERT/UPDATE/DELETE executes once, updates all 5 columns

  bank_transactions:
    foreign_keys:
      account_fk:
        table: bank_accounts
        # Consider adding index hints for very high volume
        index: true

    columns:
      transaction_id:
        $ref: id

      account_fk:
        type: integer
        required: true

      amount: null

      created_at:
        $ref: timestamp

  # CASE 2: Wide fan-out scenario
  # One parent record with millions of children
  popular_posts:
    columns:
      post_id:
        $ref: id

      # With 1M+ comments, COUNT automation is still O(1) for incremental updates
      comment_count:
        type: integer
        automation:
          type: COUNT
          table: post_comments
          foreign_key: post_fk
          column: comment_id

      # SUM is O(1) for incremental updates even with millions of likes
      total_likes:
        type: integer
        automation:
          type: SUM
          table: comment_likes
          foreign_key: comment_fk
          column: like_value
        # Note: This would require joining through comments

      # Performance consideration: LATEST is always O(1)
      latest_comment_time:
        $ref: timestamp
        automation:
          type: LATEST
          table: post_comments
          foreign_key: post_fk
          column: created_at

  post_comments:
    foreign_keys:
      post_fk:
        table: popular_posts

    columns:
      comment_id:
        $ref: id

      post_fk:
        type: integer
        required: true

      created_at:
        $ref: timestamp

  comment_likes:
    foreign_keys:
      comment_fk:
        table: post_comments

    columns:
      like_id:
        $ref: id

      comment_fk:
        type: integer
        required: true

      like_value:
        type: integer
        # +1 for like, -1 for dislike

  # CASE 3: Challenging DELETE scenario
  # DELETE operations can be expensive when they affect extreme values
  sales_teams:
    columns:
      team_id:
        $ref: id

      # If we DELETE the current MAX sale, trigger must recalculate
      highest_sale:
        $ref: amount
        automation:
          type: MAX
          table: sales_records
          foreign_key: team_fk
          column: sale_amount
        # DELETE of max value triggers: SELECT MAX(...) FROM sales_records

      # If we DELETE the current MIN sale, trigger must recalculate
      lowest_sale:
        $ref: amount
        automation:
          type: MIN
          table: sales_records
          foreign_key: team_fk
          column: sale_amount

      # SUM and COUNT remain O(1) even for DELETE
      total_sales:
        $ref: amount
        automation:
          type: SUM
          table: sales_records
          foreign_key: team_fk
          column: sale_amount

      sale_count:
        type: integer
        automation:
          type: COUNT
          table: sales_records
          foreign_key: team_fk
          column: sale_id

  sales_records:
    foreign_keys:
      team_fk:
        table: sales_teams

    columns:
      sale_id:
        $ref: id

      team_fk:
        type: integer
        required: true

      sale_amount:
        $ref: amount

  # CASE 4: UPDATE performance edge case
  # Updating the current extreme value requires recalculation
  student_grades:
    columns:
      student_id:
        $ref: id

      # Updating current highest grade requires recalculation
      highest_grade:
        type: integer
        automation:
          type: MAX
          table: test_scores
          foreign_key: student_fk
          column: score

      # Average recalculates on every UPDATE regardless
      average_grade:
        type: numeric
        size: 5
        decimal: 2
        automation:
          type: AVG
          table: test_scores
          foreign_key: student_fk
          column: score

  test_scores:
    foreign_keys:
      student_fk:
        table: student_grades

    columns:
      score_id:
        $ref: id

      student_fk:
        type: integer
        required: true

      score:
        type: integer

# Performance characteristics by automation type:
#
# SUM automation:
#   INSERT: O(1) - add new value
#   UPDATE: O(1) - subtract old, add new
#   DELETE: O(1) - subtract deleted value
#   Best case: Always optimal
#
# COUNT automation:
#   INSERT: O(1) - increment counter
#   UPDATE: O(1) - check NULL transitions
#   DELETE: O(1) - decrement counter
#   Best case: Always optimal
#
# MAX automation:
#   INSERT: O(1) - compare with current max
#   UPDATE: O(1) if new value ≤ current max, O(n) if current max changes to lower
#   DELETE: O(1) if deleted ≠ current max, O(n) if deleted == current max
#   Worst case: DELETE/UPDATE of extreme values
#
# MIN automation:
#   Same complexity as MAX
#
# LATEST automation:
#   INSERT: O(1) - new value wins
#   UPDATE: O(1) - new value wins
#   DELETE: O(n) if deleted was most recent (must find new latest)
#   Worst case: DELETE of most recent record
#
# AVG automation:
#   INSERT: O(1) - incremental average calculation
#   UPDATE: O(1) - adjust sum and count
#   DELETE: O(1) - adjust sum and count
#   Best case: Always optimal with incremental algorithms
#
# Optimization strategies:
#
# 1. Index foreign key columns for large child tables
# 2. Consider partitioning for time-series data
# 3. Use composite indexes for complex queries
# 4. Monitor for DELETE/UPDATE of extreme values in high-volume scenarios
# 5. Consider denormalization alternatives for read-heavy workloads with extreme scale
#
# GenLogic's consolidation benefit:
# - Traditional approach: N automations = N triggers = N table scans
# - GenLogic approach: N automations = 1 trigger = 1 table scan
# - Performance improvement scales with number of automations per FK relationship